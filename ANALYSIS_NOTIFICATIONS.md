# Анализ производительности системы нотификаций

## Текущая архитектура

### Модели данных:
1. **NotificationSchedule** - расписание пользователя
   - `chatId` (индексирован)
   - `daysOfWeek: DayOfWeek[]` - массив дней недели
   - `times: ScheduleTime[]` - массив времен (до 3)
   - `isActive: boolean`

2. **NotificationSent** - история отправленных нотификаций
   - `chatId` (индексирован)
   - `scheduledDate` (индексирован)
   - `hour`, `minute`, `dayOfWeek`
   - Уникальный индекс: `{chatId, scheduledDate, hour, minute}`

### Текущий алгоритм работы (notification-cron.processor.ts):
```
1. Каждую минуту запускается cron job
2. Загружаются ВСЕ активные расписания (findAllActive)
3. Для каждого расписания:
   a. Запрос к БД: findByChatId (получить пользователя и timezone)
   b. Вычисление текущего времени пользователя в его timezone
   c. Проверка в памяти: schedule.daysOfWeek.includes(currentDayOfWeek)
   d. Для каждого времени в schedule.times:
      - Проверка совпадения времени (±5 минут)
      - Запрос к БД: wasSent() - проверка, была ли уже отправлена
      - Если не было: отправка + markAsSent() - еще один запрос к БД
```

## Критические проблемы производительности

### ❌ Проблема 1: Загрузка всех активных расписаний в память
**Место:** `notification-cron.processor.ts:30-31`
```typescript
const activeSchedules = await this.notificationScheduleProvider.findAllActive();
```
- При 10,000 активных пользователей загружается 10,000 документов
- При 100,000 - 100,000 документов
- Каждый документ содержит массивы `daysOfWeek` и `times`
- **Память:** ~500KB-5MB данных загружается в память каждую минуту

### ❌ Проблема 2: N+1 запросы к БД для получения пользователей
**Место:** `notification-cron.processor.ts:41`
```typescript
const user = await this.userProvider.findByChatId(schedule.chatId);
```
- Для каждого расписания отдельный запрос к БД
- При 10,000 активных расписаний = 10,000 запросов каждую минуту
- Даже если 90% расписаний не подходят по дню недели - запрос все равно выполняется

### ❌ Проблема 3: Проверка дней недели в памяти
**Место:** `notification-cron.processor.ts:52`
```typescript
if (!schedule.daysOfWeek.includes(currentDayOfWeek)) {
  continue;
}
```
- Проверка происходит ПОСЛЕ загрузки расписания и получения пользователя
- Фильтрация по дню недели должна происходить на уровне БД

### ❌ Проблема 4: Множественные запросы wasSent для каждого времени
**Место:** `notification-cron.processor.ts:76-82`
```typescript
for (const time of schedule.times) {
  // ...
  const wasSent = await this.notificationSentProvider.wasSent(...);
}
```
- Для каждого времени в массиве отдельный запрос к БД
- При 3 временах и 10,000 расписаний = до 30,000 запросов каждую минуту
- Запросы выполняются даже если время не совпадает

### ❌ Проблема 5: Неэффективная проверка wasSent
**Место:** `notification-sent.provider.ts:15-34`
```typescript
async wasSent(...) {
  const dateStart = new Date(scheduledDate);
  dateStart.setHours(0, 0, 0, 0);
  const dateEnd = new Date(scheduledDate);
  dateEnd.setHours(23, 59, 59, 999);
  
  const exists = await this.notificationSentRepository.findOne({
    chatId,
    scheduledDate: { $gte: dateStart, $lte: dateEnd },
    hour, minute, dayOfWeek,
  });
}
```
- Используется диапазон дат вместо точной даты
- Хотя есть уникальный индекс `{chatId, scheduledDate, hour, minute}`

### ❌ Проблема 6: Синхронная обработка всех расписаний
**Место:** `notification-cron.processor.ts:38`
```typescript
for (const schedule of activeSchedules) {
  // обработка синхронно
}
```
- Все расписания обрабатываются последовательно в одном процессе
- Одно медленное расписание блокирует все остальные
- Нет батчинга и параллелизма

## Оценка нагрузки при масштабировании

### При 10,000 активных пользователей:
- **Загрузка расписаний:** 10,000 документов каждую минуту
- **Запросы к пользователям:** 10,000 запросов (даже если только 1,428 подходят по дню недели - 1/7)
- **Запросы wasSent:** до 30,000 запросов (10k пользователей × 3 времени)
- **Итого:** ~40,000+ запросов к БД каждую минуту = **667 запросов/сек**

### При 100,000 активных пользователей:
- **Загрузка расписаний:** 100,000 документов каждую минуту = ~5MB памяти
- **Запросы к пользователям:** 100,000 запросов
- **Запросы wasSent:** до 300,000 запросов
- **Итого:** ~400,000+ запросов к БД каждую минуту = **6,667 запросов/сек**

### Проблемы при масштабировании:
1. **БД перегружена** - тысячи запросов в секунду
2. **Память переполняется** - загрузка всех расписаний
3. **Время выполнения** - при 100k пользователей обработка может занять минуты
4. **Нет масштабирования** - невозможно распараллелить
5. **Отказоустойчивость** - падение одного пользователя ломает весь процесс

## План переработки

### Стратегия: Переход от "pull-based" к "push-based" подходу

### Фаза 1: Оптимизация текущей модели (краткосрочное решение)

#### 1.1. Фильтрация на уровне БД по текущему дню недели
**Проблема:** Сейчас все расписания загружаются, потом фильтруются в памяти

**Решение:**
- Добавить агрегацию MongoDB для фильтрации по `daysOfWeek` на уровне БД
- Или использовать `$elemMatch` в запросе
- Уменьшить количество загружаемых расписаний в ~7 раз (только подходящие дни)

```typescript
// Новый метод в repository
findActiveByDayOfWeek(dayOfWeek: DayOfWeek) {
  return this.model.find({
    isActive: true,
    daysOfWeek: dayOfWeek  // MongoDB автоматически найдет в массиве
  });
}
```

#### 1.2. Batch загрузка пользователей с timezone
**Проблема:** N+1 запросы для получения пользователей

**Решение:**
- Загрузить все нужные пользователи одним запросом с `$in`
- Создать Map для быстрого доступа

```typescript
// Загрузить всех пользователей сразу
const chatIds = activeSchedules.map(s => s.chatId);
const users = await this.userProvider.findByChatIds(chatIds);
const userMap = new Map(users.map(u => [u.chatId, u]));
```

#### 1.3. Оптимизация проверки wasSent
**Проблема:** Используется диапазон дат вместо точной даты

**Решение:**
- Использовать точную дату начала дня в UTC
- Использовать составной индекс для быстрого поиска
- Можно использовать `exists()` вместо `findOne()` для булевого результата

#### 1.4. Предварительная фильтрация по времени
**Проблема:** Проверка всех времен в цикле

**Решение:**
- Фильтровать времена ДО запроса к БД
- Проверять только времена в интервале текущего времени ±5 минут

#### 1.5. Параллельная обработка
**Проблема:** Последовательная обработка всех расписаний

**Решение:**
- Использовать `Promise.all` с батчами (например, по 100 расписаний)
- Ограничить параллелизм (например, 10 одновременных обработок)

**Ожидаемый эффект:**
- Уменьшение запросов к БД в 7-10 раз
- Ускорение обработки в 5-10 раз
- Масштабирование до ~50,000 пользователей

---

### Фаза 2: Переход на индексированную модель (среднесрочное решение)

#### 2.1. Создание индексированной таблицы предстоящих нотификаций
**Концепция:** Вместо проверки всех расписаний каждую минуту, создавать записи о будущих нотификациях заранее

**Новая модель: NotificationPending**
```typescript
@Schema({ timestamps: true })
export class NotificationPending {
  @Prop({ required: true, index: true })
  chatId: number;

  @Prop({ required: true, index: true })
  scheduledAt: Date;  // Точное время отправки в UTC

  @Prop({ required: true })
  timezone: string;

  @Prop({ required: true, index: true })
  status: 'pending' | 'sent' | 'skipped';

  @Prop({ default: Date.now, index: true })
  createdAt: Date;
}

// Составные индексы:
// { scheduledAt: 1, status: 1 } - для поиска нотификаций к отправке
// { chatId: 1, scheduledAt: 1 } - для поиска по пользователю
// TTL индекс на scheduledAt для автоудаления старых записей
```

#### 2.2. Генерация pending нотификаций
**Механизм:**
- При создании/изменении расписания генерировать pending нотификации на ближайшие 7-14 дней
- Отдельный cron job (раз в день) генерирует нотификации на следующий период
- Использовать батчинг для массовой вставки

**Пример:**
```typescript
async generatePendingNotifications(schedule: NotificationSchedule, user: User) {
  const notifications = [];
  const startDate = new Date();
  const endDate = addDays(startDate, 14);
  
  for (let date = startDate; date <= endDate; date = addDays(date, 1)) {
    const dayOfWeek = date.getDay();
    if (!schedule.daysOfWeek.includes(dayOfWeek)) continue;
    
    for (const time of schedule.times) {
      const scheduledAt = setHours(setMinutes(startOfDay(date), time.minute), time.hour);
      const scheduledAtUTC = fromZonedTime(scheduledAt, user.timezone);
      
      notifications.push({
        chatId: schedule.chatId,
        scheduledAt: scheduledAtUTC,
        timezone: user.timezone,
        status: 'pending'
      });
    }
  }
  
  // Batch insert
  await this.notificationPendingRepository.insertMany(notifications);
}
```

#### 2.3. Оптимизированный процессор
**Новый алгоритм:**
```typescript
async process(job: Job): Promise<void> {
  const now = new Date();
  const windowStart = now;
  const windowEnd = addMinutes(now, 5); // Окно в 5 минут
  
  // Найти все pending нотификации в окне времени (ОДИН запрос!)
  const pendingNotifications = await this.notificationPendingRepository.find({
    scheduledAt: { $gte: windowStart, $lte: windowEnd },
    status: 'pending'
  });
  
  // Обработать найденные нотификации
  for (const notification of pendingNotifications) {
    await this.sendAndMarkAsSent(notification);
  }
}
```

**Преимущества:**
- Один запрос к БД вместо тысяч
- Масштабирование до миллионов пользователей
- Предсказуемое время выполнения
- Легко распараллелить (по диапазонам времени)

**Ожидаемый эффект:**
- Масштабирование до 1,000,000+ пользователей
- Снижение нагрузки на БД в 100-1000 раз
- Время выполнения < 1 секунды независимо от количества пользователей

---

### Фаза 3: Дополнительные оптимизации (долгосрочное решение)

#### 3.1. Кэширование
- Redis для кэширования активных расписаний
- Кэширование timezone пользователей
- Инвалидация при изменении расписания

#### 3.2. Шардинг по времени
- Разделить обработку по временным слотам
- Разные воркеры обрабатывают разные минуты
- Load balancing между воркерами

#### 3.3. Отложенная отправка
- Использовать очереди (BullMQ) для отправки нотификаций
- Batch отправка для одного пользователя
- Retry механизм для failed отправок

#### 3.4. Архивация старых данных
- Перемещение старых NotificationSent в архивную коллекцию
- TTL индексы для автоудаления
- Сжатие данных

---

## Рекомендации по внедрению

### Приоритет 1 (критично, делать немедленно):
1. ✅ Фильтрация по дню недели на уровне БД
2. ✅ Batch загрузка пользователей
3. ✅ Оптимизация wasSent с использованием точной даты

**Время внедрения:** 1-2 дня
**Эффект:** Улучшение в 5-10 раз, масштабирование до 50k пользователей

### Приоритет 2 (важно, в течение месяца):
1. ✅ Переход на NotificationPending модель
2. ✅ Генерация pending нотификаций при изменении расписания
3. ✅ Оптимизированный процессор с одним запросом

**Время внедрения:** 1 неделя
**Эффект:** Улучшение в 100-1000 раз, масштабирование до 1M+ пользователей

### Приоритет 3 (желательно, в течение квартала):
1. ✅ Кэширование
2. ✅ Шардинг
3. ✅ Архивация

**Время внедрения:** 2-3 недели
**Эффект:** Дополнительная оптимизация, готовность к экстремальным нагрузкам

---

## Метрики для отслеживания

### До оптимизации (базовые метрики):
- Количество активных расписаний
- Время выполнения cron job
- Количество запросов к БД в минуту
- Использование памяти
- Количество отправленных нотификаций

### После оптимизации (целевые метрики):
- **Время выполнения:** < 5 секунд (даже при 100k пользователей)
- **Запросы к БД:** < 100 запросов/минуту
- **Память:** < 100MB для обработки
- **Пропускная способность:** > 10,000 нотификаций/минуту

---

## Риски и митигация

### Риск 1: Миграция данных
**Решение:** Постепенная миграция, dual-write период, откат план

### Риск 2: Потеря нотификаций при сбое
**Решение:** Retry механизм, dead letter queue, мониторинг

### Риск 3: Перегрузка при генерации pending
**Решение:** Batch обработка, rate limiting, фоновая генерация

---

## Заключение

Текущая архитектура **не масштабируется** и при росте пользователей приведет к:
- Перегрузке БД (тысячи запросов/сек)
- Переполнению памяти
- Медленной обработке (минуты вместо секунд)
- Отказам в обслуживании

**Рекомендация:** Начать с Фазы 1 немедленно, планировать Фазу 2 в течение месяца.

